# Simulation Analysis

When used in standalone mode, `nova` simply emits a FASTA containing reads with simulated insertions. These reads are be mapped to the same reference genome as the origin BAM file and merged to create a simulation BAM file, which can then be used for variant calling.

There are a number of scripts in the `scripts` directory that can be used to analyze the resultant variant callsets:

## `analyze_vcf_results.py`

This script analyzes Sniffles2 VCF results to identify variants supported by nova simulated reads and evaluate detection performance.

### Purpose

The script loads VCF data from a joblib file (generated by the Snakemake pipeline) and performs comprehensive analysis to:
- Identify variants containing nova-simulated reads
- Calculate true positive rates and detection quality
- Categorize variants by multiple dimensions (SVTYPE, precision, read support)
- Verify mapping accuracy of detected reads
- Compare detected variant sizes with simulated insertion sizes
- Analyze false positive patterns

### Usage

```bash
python scripts/analyze_vcf_results.py output_dir [options]
```

#### Arguments:
- `output_dir`: Path to the nova simulation output directory containing:
  - `{prefix}_simulation.jl`: Joblib file with VCF data
  - `{prefix}_insertions.json`: JSON file with insertion metadata
  - `{prefix}_modified_reads.bam`: BAM file with aligned modified reads

#### Options:
- `--output-prefix`: Output file prefix (default: "nova")
- `--original-bam`: Path to original BAM file (default: tests/test_data/test_reads.bam)

### Key Features

1. **Variant Identification**: Scans all variants to find those containing reads with "nova" in their name
2. **Mapping Verification**: Compares alignment positions of nova reads against their original positions to identify true positives vs mapping errors
3. **Multi-dimensional Categorization**:
   - By SVTYPE (INS, DEL, DUP, etc.)
   - By precision (PRECISE/IMPRECISE)
   - By support level (Low: 1-2, Medium: 3-5, High: 6+ reads)
   - By read composition:
     - `single_nova_only`: Single read support, nova read only (true positives)
     - `majority_nova`: â‰¥50% nova reads
     - `minority_nova`: <50% nova reads
4. **False Positive Analysis**: Identifies patterns in false positives including genomic clustering and identical sequences
5. **Size Accuracy Analysis**: Compares generated insertion sizes with detected SVLEN values

### Output Files

The script generates two main output files:

1. **CSV File** (`{prefix}_analysis.csv`): Detailed tabular data for each variant including:
   - Variant coordinates and type information
   - Read support metrics and nova fractions
   - Categorization results
   - Mapping verification status
   - Size comparison data
   - False positive pattern indicators

2. **Summary JSON** (`{prefix}_analysis_summary.json`): Lightweight summary containing:
   - Overall detection metrics (true positive rate, false positive count)
   - Performance breakdown by insertion type
   - Composition and variant type distributions
   - False positive analysis summary

### Example Output

```
====================================================
NOVA VARIANT DETECTION ANALYSIS
====================================================

Total variants with nova reads: 1086

1. TRUE POSITIVE ANALYSIS (Single nova-Only Calls):
   alu: 98/100 true positives (98.0%), 98 reads utilized (98.0%)
   simple: 195/200 true positives (97.5%), 196 reads utilized (98.0%)
   random: 385/400 true positives (96.3%), 390 reads utilized (97.5%)
   OVERALL: 678/700 true positives (96.9%)
   READ UTILIZATION: 684/700 nova reads detected (97.7%)

2. DETECTION QUALITY ANALYSIS:
   Total variants detected: 1086
   Single nova-only calls: 678
     - Correct mapping (true positives): 675 (96.4%)
     - Incorrect mapping (mapping errors): 3 (0.4%)
     - Unknown mapping status: 0
   False positives (multi-read/mixed): 408
```

## `vcf_intersection.py`

This script analyzes variant intersections across multiple VCF files, identifying shared and private variants based on multiple matching criteria.

### Purpose

Derived from truvari's consistency analysis, this script:
- Identifies matching variants across VCFs using CHROM, POS, REF, ALT, SVTYPE, and SVLEN
- Calculates intersection statistics and consistency metrics
- Generates private variant ID lists for filtering
- Supports flexible matching modes (with or without ALT field)

### Usage

```bash
python scripts/vcf_intersection.py vcf1.vcf vcf2.vcf [vcf3.vcf ...] [options]
```

#### Options:
- `--ignore-alt`: Ignore ALT field in matching (useful for comparing mutated sequences)
- `--json`: Output results in JSON format instead of console report
- `--report-pids PREFIX`: Generate private variant ID files with given prefix

### Key Features

1. **Flexible Matching**: Variants are matched based on composite key:
   - Standard mode: `CHROM:POS:REF:ALT:SVTYPE:SVLEN`
   - Ignore-alt mode: `CHROM:POS:REF:SVTYPE:SVLEN`

2. **Comprehensive Reporting**:
   - Total unique variants across all VCFs
   - Per-VCF variant counts
   - Shared variant statistics (variants in 1, 2, ..., N VCFs)
   - Detailed breakdown by presence pattern

3. **Private Variant Extraction**: Generates text files containing variant IDs unique to each VCF, compatible with bcftools filtering:
   ```bash
   bcftools view -i 'ID=@01.txt' input.vcf.gz -o private_variants.vcf
   ```

### Output Formats

#### Console Report (default):
```
#
# Total 1500 calls across 3 VCFs
#
#File    NumCalls
vcf1.vcf.gz    800
vcf2.vcf.gz    750
vcf3.vcf.gz    820
#
# Summary of consistency
#
#VCFs    Calls    Pct
3        650      43.33%
2        200      13.33%
1        650      43.33%
#
# Breakdown of VCFs' consistency
#
#Group    Total    TotalPct
111      650      43.33%
110      100      6.67%
101      50       3.33%
...
```

#### JSON Format (`--json`):
```json
{
    "vcfs": ["vcf1.vcf.gz", "vcf2.vcf.gz", "vcf3.vcf.gz"],
    "total_calls": 1500,
    "num_vcfs": 3,
    "vcf_counts": {
        "vcf1.vcf.gz": 800,
        "vcf2.vcf.gz": 750,
        "vcf3.vcf.gz": 820
    },
    "shared": [
        {"vcf_count": 3, "num_calls": 650, "call_pct": 0.4333},
        {"vcf_count": 2, "num_calls": 200, "call_pct": 0.1333},
        {"vcf_count": 1, "num_calls": 650, "call_pct": 0.4333}
    ],
    "detailed": [
        {
            "group": "111",
            "total": 650,
            "total_pct": 0.4333,
            "vcf1.vcf.gz": 0.8125,
            "vcf2.vcf.gz": 0.8667,
            "vcf3.vcf.gz": 0.7927
        }
    ]
}
```

### Use Cases

1. **Multi-caller Comparison**: Compare variant calls from different SV callers on the same data
2. **Mutation Analysis**: Use `--ignore-alt` to track variants regardless of inserted sequence changes
3. **Filtering**: Generate private variant lists for downstream analysis
4. **Quality Control**: Assess consistency between technical replicates